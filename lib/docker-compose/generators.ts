import type { DockerSettings } from "@/components/settings-panel";
import type { DockerTool } from "@/lib/docker-tools";
import { detectAndFixPortConflicts } from "./port-conflicts";

/**
 * Generates environment file content based on Docker settings
 * @param settings User's docker settings
 * @returns Generated .env file content
 */
export function generateEnvFileContent(settings: DockerSettings): string {
  return `# Docker Compose Environment Variables
# These can be overridden by setting them in your shell or in a .env file

# User/Group Identifiers
# These help avoid permission issues between host and container
PUID=${settings.puid}
PGID=${settings.pgid}
UMASK=${settings.umask}

# Container name prefix
CONTAINER_PREFIX=${settings.containerNamePrefix}

# Paths for persistent data
CONFIG_PATH=${settings.configPath}
DATA_PATH=${settings.dataPath}

# Container settings
TZ=${settings.timezone}
RESTART_POLICY=${settings.restartPolicy}
NETWORK_MODE=${settings.networkMode}
`
}

/**
 * Generates docker-compose.yaml content based on selected tools and settings
 * @param selectedTools Array of selected Docker tools
 * @param settings User's docker settings
 * @param showInterpolated Whether to show interpolated values or variables
 * @returns Object containing generated content and detected port conflicts
 */
export function generateComposeContent(
  selectedTools: DockerTool[],
  settings: DockerSettings,
  showInterpolated: boolean
): {
  content: string;
  portConflicts: { fixed: number; conflicts: string[] } | null;
} {
  // Create docker-compose header
  const composeHeader = `#  ____   ____ __  __ 
# |  _ \\ / ___|  \\/  |
# | | | | |   | |\\/| | This compose file was generated by DCM: https://github.com/ajnart/docker-compose-maker
# | |_| | |___| |  | |
# |____/ \\____|_|  |_|
#
`

  // Generate services section
  let servicesSection = `services:
`

  // Add each selected tool
  selectedTools.forEach((tool) => {
    if (!tool.composeContent) return
    // Add a blank line before each service
    servicesSection += `
`
    // Add a comment with the tool description
    servicesSection += `  # ${tool.name}: ${tool.description}
`
    // Process the compose content - properly indent everything
    let toolContent = tool.composeContent.replace(/^services:\s*/gm, "") // Remove the services: line

    // Create a more robust indentation system for nested YAML
    const lines = toolContent.split("\n")
    let currentIndentLevel = 0

    const processedLines = lines.map((line, index) => {
      // Skip empty lines
      if (line.trim() === "") return line

      const trimmedLine = line.trim()
      const isServiceLine = index === 0 || lines[index - 1].trim() === ""

      // Reset indent level for service lines
      if (isServiceLine) {
        currentIndentLevel = 0
        return `  ${trimmedLine}` // 2 spaces for service name
      }

      // Determine if this line defines a new block (ends with colon)
      const definesBlock =
        trimmedLine.endsWith(":") && !trimmedLine.includes(": ")

      // Check if previous line defined a block (which would make this line deeper)
      const prevLine = index > 0 ? lines[index - 1].trim() : ""
      const prevDefinesBlock =
        prevLine.endsWith(":") && !prevLine.includes(": ")

      // Increase indent level if previous line defined a block
      if (prevDefinesBlock) {
        currentIndentLevel++
      }
      // Detect decrease in indentation by checking original indentation
      else if (!isServiceLine && index > 0) {
        const originalIndent = line.match(/^\s*/)?.[0].length || 0
        const prevOriginalIndent =
          lines[index - 1].match(/^\s*/)?.[0].length || 0

        // If current line has less original indentation than previous line,
        // we need to decrease our indentation level
        if (originalIndent < prevOriginalIndent) {
          // Calculate how many levels to go back based on the difference
          const levels = Math.floor((prevOriginalIndent - originalIndent) / 2)
          currentIndentLevel = Math.max(0, currentIndentLevel - levels)
        }
      }

      // Calculate spaces for the current indent level (base of 2 + 2 per level)
      const spaces = 2 + currentIndentLevel * 2
      return `${" ".repeat(spaces)}${trimmedLine}`
    })

    toolContent = processedLines.join("\n")

    // Replace variables with their values if showInterpolated is true
    if (showInterpolated) {
      toolContent = toolContent
        .replace(/\$\{CONFIG_PATH\}/g, settings.configPath)
        .replace(/\$\{DATA_PATH\}/g, settings.dataPath)
        .replace(/\$\{TZ\}/g, settings.timezone)
        .replace(/\$\{PUID\}/g, settings.puid)
        .replace(/\$\{PGID\}/g, settings.pgid)
        .replace(/\$\{UMASK\}/g, settings.umask)
        .replace(/\$\{RESTART_POLICY\}/g, settings.restartPolicy)
        .replace(/\$\{NETWORK_MODE\}/g, settings.networkMode)
        .replace(/\$\{CONTAINER_PREFIX\}/g, settings.containerNamePrefix)
    }

    servicesSection += `${toolContent}\n`
  })

  const completeCompose = composeHeader + servicesSection

  // Detect and fix port conflicts
  const { fixedContent, conflicts } = detectAndFixPortConflicts(completeCompose)

  return {
    content: fixedContent,
    portConflicts: conflicts,
  }
} 